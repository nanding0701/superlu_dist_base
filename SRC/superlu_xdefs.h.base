/*! \file
Copyright (c) 2003, The Regents of the University of California, through
Lawrence Berkeley National Laboratory (subject to receipt of any required 
approvals from U.S. Dept. of Energy) 

All rights reserved. 

The source code is distributed under BSD license, see the file License.txt
at the top-level directory.
*/
@extract -b Typedef.inc
/*! @file 
 * \brief  Distributed SuperLU data types and function prototypes
 *
 * <pre>
 * -- Distributed SuperLU routine (version 4.1) --
 * Lawrence Berkeley National Lab, Univ. of California Berkeley.
 * November 1, 2007
 * April 5, 2015
 * </pre>
 */

#ifndef __SUPERLU_@(pre)DEFS /* allow multiple inclusions */
#define __SUPERLU_@(pre)DEFS

/*
 * File name:	superlu_@(pre)defs.h
 * Purpose:     Distributed SuperLU data types and function prototypes
 * History:
 */

#include "superlu_defs.h"
@precision DCOMPLEX
#include "dcomplex.h"
@precision !

/*-- Auxiliary data type used in PxGSTRS/PxGSTRS1. */
typedef struct {
    int_t lbnum;  /* Row block number (local).      */
    int_t indpos; /* Starting position in Uindex[]. */
} Ucb_indptr_t;

/* 
 * On each processor, the blocks in L are stored in compressed block
 * column format, the blocks in U are stored in compressed block row format.
 */
#define MAX_LOOKAHEADS 50
typedef struct {
    int_t   **Lrowind_bc_ptr; /* size ceil(NSUPERS/Pc)                 */
    @(type)  **Lnzval_bc_ptr;  /* size ceil(NSUPERS/Pc)                 */
    int_t   **Ufstnz_br_ptr;  /* size ceil(NSUPERS/Pr)                 */
    @(type)  **Unzval_br_ptr;  /* size ceil(NSUPERS/Pr)                 */
#if 0
    int_t   *Lsub_buf;        /* Buffer for the remote subscripts of L */
    double  *Lval_buf;        /* Buffer for the remote nonzeros of L   */
    int_t   *Usub_buf;        /* Buffer for the remote subscripts of U */
    @(type)  *Uval_buf;        /* Buffer for the remote nonzeros of U   */
#endif
    int_t   *Lsub_buf_2[MAX_LOOKAHEADS];   /* Buffers for the remote subscripts of L*/
    @(type)  *Lval_buf_2[MAX_LOOKAHEADS];   /* Buffers for the remote nonzeros of L  */
    int_t   *Usub_buf_2[MAX_LOOKAHEADS];   /* Buffer for the remote subscripts of U */
    @(type)  *Uval_buf_2[MAX_LOOKAHEADS];   /* Buffer for the remote nonzeros of U   */
    @(type)  *ujrow;           /* used in panel factorization.          */
    int_t   bufmax[NBUFFERS]; /* Maximum buffer size across all MPI ranks:
			       *  0 : maximum size of Lsub_buf[]
			       *  1 : maximum size of Lval_buf[]
			       *  2 : maximum size of Usub_buf[] 
			       *  3 : maximum size of Uval_buf[]
			       *  4 : maximum size of tempv[LDA]
			       */

    /*-- Record communication schedule for factorization. --*/
    int   *ToRecv;          /* Recv from no one (0), left (1), and up (2).*/
    int   *ToSendD;         /* Whether need to send down block row.       */
    int   **ToSendR;        /* List of processes to send right block col. */

    /*-- Record communication schedule for forward/back solves. --*/
    int_t   *fmod;            /* Modification count for L-solve            */
    int_t   **fsendx_plist;   /* Column process list to send down Xk       */
    int_t   *frecv;           /* Modifications to be recv'd in proc row    */
    int_t   nfrecvx;          /* Number of Xk I will receive in L-solve    */
    int_t   nfsendx;          /* Number of Xk I will send in L-solve       */
    int_t   *bmod;            /* Modification count for U-solve            */
    int_t   **bsendx_plist;   /* Column process list to send down Xk       */
    int_t   *brecv;           /* Modifications to be recv'd in proc row    */
    int_t   nbrecvx;          /* Number of Xk I will receive in U-solve    */
    int_t   nbsendx;          /* Number of Xk I will send in U-solve       */
    int_t   *mod_bit;         /* Flag contribution from each row blocks    */

    /*-- Auxiliary arrays used for forward/back solves. --*/
    int_t   *ilsum;           /* Starting position of each supernode in lsum
				 (local)  */
    int_t   ldalsum;          /* LDA of lsum (local) */
    int_t   SolveMsgSent;     /* Number of actual messages sent in LU-solve */
    int_t   SolveMsgVol;      /* Volume of messages sent in the solve phase */


    /*********************/	
    /* The following variables are used in the hybrid solver */

    /*-- Counts to be used in U^{-T} triangular solve. -- */
    int_t UT_SOLVE;
    int_t L_SOLVE;
    int_t FRECV;
    int_t ut_ldalsum;        /* LDA of lsum (local) */
    int_t *ut_ilsum;         /* ilsum in column-wise                        */
    int_t *utmod;            /* Modification count for Ut-solve.            */
    int_t **ut_sendx_plist;  /* Row process list to send down Xk            */
    int_t *utrecv;           /* Modifications to be recev'd in proc column. */
    int_t n_utsendx;         /* Number of Xk I will receive                 */
    int_t n_utrecvx;         /* Number of Xk I will send                    */
    int_t n_utrecvmod;
    int_t nroot;
    int_t *ut_modbit;
    int_t *Urbs;
    Ucb_indptr_t **Ucb_indptr;/* Vertical linked list pointing to Uindex[] */
    int_t  **Ucb_valptr;      /* Vertical linked list pointing to Unzval[] */

    /* some additional counters for L solve */
    int_t n;
    int_t nleaf;
    int_t nfrecvmod;
} LocalLU_t;


typedef struct {
    int_t *etree;
    Glu_persist_t *Glu_persist;
    LocalLU_t *Llu;
} LUstruct_t;


/*-- Data structure for communication during matrix-vector multiplication. */
typedef struct {
    int_t *extern_start;
    int_t *ind_tosend;    /* X indeices to be sent to other processes */
    int_t *ind_torecv;    /* X indeices to be received from other processes */
    int_t *ptr_ind_tosend;/* Printers to ind_tosend[] (Size procs)
			     (also point to val_torecv) */
    int_t *ptr_ind_torecv;/* Printers to ind_torecv[] (Size procs)
			     (also point to val_tosend) */
    int   *SendCounts;    /* Numbers of X indices to be sent
			     (also numbers of X values to be received) */
    int   *RecvCounts;    /* Numbers of X indices to be received
			     (also numbers of X values to be sent) */
    @(type) *val_tosend;   /* X values to be sent to other processes */
    @(type) *val_torecv;   /* X values to be received from other processes */
    int_t TotalIndSend;   /* Total number of indices to be sent
			     (also total number of values to be received) */
    int_t TotalValSend;   /* Total number of values to be sent.
			     (also total number of indices to be received) */
} p@(pre)gsmv_comm_t;

/*-- Data structure holding the information for the solution phase --*/
typedef struct {
    int_t *row_to_proc;
    int_t *inv_perm_c;
    int_t num_diag_procs, *diag_procs, *diag_len;
    p@(pre)gsmv_comm_t *gsmv_comm; /* communication metadata for SpMV, 
         	       		      required by IterRefine.          */
    pxgstrs_comm_t *gstrs_comm;  /* communication metadata for SpTRSV. */
    int_t *A_colind_gsmv; /* After p@(pre)gsmv_init(), the global column
                             indices of A are translated into the relative
                             positions in the gathered x-vector.
                             This is re-used in repeated calls to p@(pre)gsmv() */
    /*int_t *xrow_to_proc; Xiaoye: can be removed */
} SOLVEstruct_t;


/***********************************************************************
 * Function prototypes
 ***********************************************************************/

#ifdef __cplusplus
extern "C" {
#endif


/* Supernodal LU factor related */
extern void
@(pre)Create_CompCol_Matrix_dist(SuperMatrix *, int_t, int_t, int_t, @(type) *,
			    int_t *, int_t *, Stype_t, Dtype_t, Mtype_t);
extern void
@(pre)Create_CompRowLoc_Matrix_dist(SuperMatrix *, int_t, int_t, int_t, int_t,
			       int_t, @(type) *, int_t *, int_t *,
			       Stype_t, Dtype_t, Mtype_t);
extern void
@(pre)CompRow_to_CompCol_dist(int_t, int_t, int_t, @(type) *, int_t *, int_t *,
                         @(type) **, int_t **, int_t **);
extern int
p@(pre)CompRow_loc_to_CompCol_global(int_t, SuperMatrix *, gridinfo_t *,
	 		        SuperMatrix *);
extern void
@(pre)Copy_CompCol_Matrix_dist(SuperMatrix *, SuperMatrix *);
extern void
@(pre)Create_Dense_Matrix_dist(SuperMatrix *, int_t, int_t, @(type) *, int_t,
			  Stype_t, Dtype_t, Mtype_t);
extern void
@(pre)Create_SuperNode_Matrix_dist(SuperMatrix *, int_t, int_t, int_t, @(type) *, 
			      int_t *, int_t *, int_t *, int_t *, int_t *,
			      Stype_t, Dtype_t, Mtype_t);
extern void
@(pre)Copy_Dense_Matrix_dist(int_t, int_t, @(type) *, int_t,
                        @(type) *, int_t);

extern void    @(pre)allocateA_dist (int_t, int_t, @(type) **, int_t **, int_t **);
extern void    @(pre)GenXtrue_dist (int_t, int_t, @(type) *, int_t);
extern void    @(pre)FillRHS_dist (char *, int_t, @(type) *, int_t,
                              SuperMatrix *, @(type) *, int_t);
extern int     @(pre)create_matrix(SuperMatrix *, int, @(type) **, int *, 
			      @(type) **, int *, FILE *, gridinfo_t *);
extern int     @(pre)create_matrix_rb(SuperMatrix *, int, @(type) **, int *, 
			      @(type) **, int *, FILE *, gridinfo_t *);
extern int     @(pre)create_matrix_dat(SuperMatrix *, int, @(type) **, int *, 
			      @(type) **, int *, FILE *, gridinfo_t *);

/* Driver related */
extern void    @(pre)gsequ_dist (SuperMatrix *, double *, double *, double *,
			    double *, double *, int_t *);
extern double  @(pre)langs_dist (char *, SuperMatrix *);
extern void    @(pre)laqgs_dist (SuperMatrix *, double *, double *, double,
			    double, double, char *);
extern void    p@(pre)gsequ (SuperMatrix *, double *, double *, double *,
			double *, double *, int_t *, gridinfo_t *);
extern double  p@(pre)langs (char *, SuperMatrix *, gridinfo_t *);
extern void    p@(pre)laqgs (SuperMatrix *, double *, double *, double,
			double, double, char *);
extern int     p@(pre)Permute_Dense_Matrix(int_t, int_t, int_t [], int_t[],
				      @(type) [], int, @(type) [], int, int,
				      gridinfo_t *);

extern int     sp_@(pre)trsv_dist (char *, char *, char *, SuperMatrix *,
			      SuperMatrix *, @(type) *, int *);
extern int     sp_@(pre)gemv_dist (char *, @(type), SuperMatrix *, @(type) *,
			      int, @(type), @(type) *, int);
extern int     sp_@(pre)gemm_dist (char *, int, @(type), SuperMatrix *,
                        @(type) *, int, @(type), @(type) *, int);

extern float @(pre)distribute(fact_t, int_t, SuperMatrix *, Glu_freeable_t *, 
			 LUstruct_t *, gridinfo_t *);
extern void  p@(pre)gssvx_ABglobal(superlu_dist_options_t *, SuperMatrix *, 
			      ScalePermstruct_t *, @(type) *,
			      int, int, gridinfo_t *, LUstruct_t *, double *,
			      SuperLUStat_t *, int *);
extern float p@(pre)distribute(fact_t, int_t, SuperMatrix *, 
			 ScalePermstruct_t *, Glu_freeable_t *, 
			 LUstruct_t *, gridinfo_t *);
extern void  p@(pre)gssvx(superlu_dist_options_t *, SuperMatrix *, 
		     ScalePermstruct_t *, @(type) *,
		     int, int, gridinfo_t *, LUstruct_t *,
		     SOLVEstruct_t *, double *, SuperLUStat_t *, int *);
extern int  @(pre)SolveInit(superlu_dist_options_t *, SuperMatrix *, int_t [], int_t [],
		       int_t, LUstruct_t *, gridinfo_t *, SOLVEstruct_t *);
extern void @(pre)SolveFinalize(superlu_dist_options_t *, SOLVEstruct_t *);
extern int_t pxgstrs_init(int_t, int_t, int_t, int_t,
                          int_t [], int_t [], gridinfo_t *grid,
	                  Glu_persist_t *, SOLVEstruct_t *);
extern void pxgstrs_finalize(pxgstrs_comm_t *);
extern int  @(pre)ldperm_dist(int_t, int_t, int_t, int_t [], int_t [],
		    @(type) [], int_t *, double [], double []);
extern int  static_schedule(superlu_dist_options_t *, int, int, 
		            LUstruct_t *, gridinfo_t *, SuperLUStat_t *,
			    int_t *, int_t *, int *);
extern void LUstructInit(const int_t, LUstruct_t *);
extern void LUstructFree(LUstruct_t *);
extern void Destroy_LU(int_t, gridinfo_t *, LUstruct_t *);

/* #define GPU_PROF
#define IPM_PROF */

extern int_t p@(pre)gstrf(superlu_dist_options_t *, int, int, double,
		    LUstruct_t*, gridinfo_t*, SuperLUStat_t*, int*);
extern void p@(pre)gstrs_Bglobal(int_t, LUstruct_t *, gridinfo_t *,
			     @(type) *, int_t, int, SuperLUStat_t *, int *);
extern void p@(pre)gstrs(int_t, LUstruct_t *, ScalePermstruct_t *, gridinfo_t *,
		    @(type) *, int_t, int_t, int_t, int, SOLVEstruct_t *,
		    SuperLUStat_t *, int *);
extern void @(pre)lsum_fmod(@(type) *, @(type) *, @(type) *, @(type) *,
		       int, int, int_t , int_t *, int_t, int_t, int_t,
		       int_t *, gridinfo_t *, LocalLU_t *, 
		       MPI_Request [], SuperLUStat_t *);
extern void @(pre)lsum_bmod(@(type) *, @(type) *, @(type) *,
                       int, int_t, int_t *, int_t *, Ucb_indptr_t **,
                       int_t **, int_t *, gridinfo_t *, LocalLU_t *,
		       MPI_Request [], SuperLUStat_t *);
extern void p@(pre)gsrfs(int_t, SuperMatrix *, double, LUstruct_t *,
		    ScalePermstruct_t *, gridinfo_t *,
		    @(type) [], int_t, @(type) [], int_t, int,
		    SOLVEstruct_t *, double *, SuperLUStat_t *, int *);
extern void p@(pre)gsrfs_ABXglobal(int_t, SuperMatrix *, double, LUstruct_t *,
		  gridinfo_t *, @(type) *, int_t, @(type) *, int_t,
		  int, double *, SuperLUStat_t *, int *);
extern int   p@(pre)gsmv_AXglobal_setup(SuperMatrix *, Glu_persist_t *,
				   gridinfo_t *, int_t *, int_t *[],
				   @(type) *[], int_t *[], int_t []);
extern int  p@(pre)gsmv_AXglobal(int_t, int_t [], @(type) [], int_t [],
	                       @(type) [], @(type) []);
extern int  p@(pre)gsmv_AXglobal_abs(int_t, int_t [], @(type) [], int_t [],
				 @(type) [], @(mod_type) []);
extern void p@(pre)gsmv_init(SuperMatrix *, int_t *, gridinfo_t *,
			p@(pre)gsmv_comm_t *);
extern void p@(pre)gsmv(int_t, SuperMatrix *, gridinfo_t *, p@(pre)gsmv_comm_t *,
		   @(type) x[], @(type) ax[]);
extern void p@(pre)gsmv_finalize(p@(pre)gsmv_comm_t *);

/* Memory-related */
extern @(type)  *@(type)Malloc_dist(int_t);
extern @(type)  *@(type)Calloc_dist(int_t);
@precision DCOMPLEX
extern double  *doubleMalloc_dist(int_t);
extern double  *doubleCalloc_dist(int_t);
@precision !
extern void  *duser_malloc_dist (int_t, int_t);
extern void  duser_free_dist (int_t, int_t);
extern int_t @(pre)QuerySpace_dist(int_t, LUstruct_t *, gridinfo_t *,
			      SuperLUStat_t *, superlu_dist_mem_usage_t *);

/* Auxiliary routines */
extern void    @(pre)fill_dist (@(type) *, int_t, @(type));
extern void    @(pre)inf_norm_error_dist (int_t, int_t, @(type)*, int_t,
                                     @(type)*, int_t, gridinfo_t*);
extern void    p@(pre)inf_norm_error(int, int_t, int_t, @(type) [], int_t,
				@(type) [], int_t , gridinfo_t *);
extern void  @(pre)readhb_dist (int, FILE *, int_t *, int_t *, int_t *, 
			   @(type) **, int_t **, int_t **);
extern void  @(pre)readtriple_dist(FILE *, int_t *, int_t *, int_t *,
			 @(type) **, int_t **, int_t **);
extern void  @(pre)readrb_dist(int, FILE *, int_t *, int_t *, int_t *,
		     @(type) **, int_t **, int_t **);
extern void  @(pre)readMM_dist(FILE *, int_t *, int_t *, int_t *,
	                  @(type) **, int_t **, int_t **);

/* Distribute the data for numerical factorization */
extern float @(pre)dist_psymbtonum(fact_t, int_t, SuperMatrix *,
                                ScalePermstruct_t *, Pslu_freeable_t *, 
                                LUstruct_t *, gridinfo_t *);
extern void p@(pre)GetDiagU(int_t, LUstruct_t *, gridinfo_t *, @(type) *);


/* Routines for debugging */
extern void  @(pre)PrintLblocks(int, int_t, gridinfo_t *, Glu_persist_t *,
		 	   LocalLU_t *);
extern void  @(pre)PrintUblocks(int, int_t, gridinfo_t *, Glu_persist_t *,
			   LocalLU_t *);
extern void  @(pre)Print_CompCol_Matrix_dist(SuperMatrix *);
extern void  @(pre)Print_Dense_Matrix_dist(SuperMatrix *);
extern int   @(pre)Print_CompRowLoc_Matrix_dist(SuperMatrix *);
@precision DOUBLE
extern int   file_PrintDouble5(FILE *, char *, int_t, double *);
@precision DCOMPLEX
extern void  PrintDoublecomplex(char *, int_t, doublecomplex *);
extern int   file_PrintDoublecomplex(FILE *fp, char *, int_t, doublecomplex *);
@precision !


/* BLAS */

#ifdef USE_VENDOR_BLAS
extern void @(pre)gemm_(const char*, const char*, const int*, const int*, const int*,
                  const @(type)*, const @(type)*, const int*, const @(type)*,
                  const int*, const @(type)*, @(type)*, const int*, int, int);
extern void @(pre)trsv_(char*, char*, char*, int*, @(type)*, int*,
                  @(type)*, int*, int, int, int);
extern void @(pre)trsm_(char*, char*, char*, char*, int*, int*, 
                  @(type)*, @(type)*, int*, @(type)*, 
                  int*, int, int, int, int);
extern void @(pre)gemv_(char *, int *, int *, @(type) *, @(type) *a, int *, 
                  @(type) *, int *, @(type) *, @(type) *, int *, int);
@precision DOUBLE
extern void @(pre)ger_(int*, int*, @(type)*, @(type)*, int*,
                 @(type)*, int*, @(type)*, int*);
@precision DCOMPLEX
extern void @(pre)geru_(int*, int*, @(type)*, @(type)*, int*,
                 @(type)*, int*, @(type)*, int*);
@precision !

#else
extern int @(pre)gemm_(const char*, const char*, const int*, const int*, const int*,
                   const @(type)*,  const @(type)*,  const int*,  const @(type)*,
                   const int*,  const @(type)*, @(type)*, const int*);
extern int @(pre)trsv_(char*, char*, char*, int*, @(type)*, int*,
                  @(type)*, int*);
extern int @(pre)trsm_(char*, char*, char*, char*, int*, int*, 
                  @(type)*, @(type)*, int*, @(type)*, int*);
extern int @(pre)gemv_(char *, int *, int *, @(type) *, @(type) *a, int *, 
                  @(type) *, int *, @(type) *, @(type) *, int *);
@precision DOUBLE
extern void @(pre)ger_(int*, int*, @(type)*, @(type)*, int*,
                 @(type)*, int*, @(type)*, int*);
@precision DCOMPLEX
extern int @(pre)geru_(int*, int*, @(type)*, @(type)*, int*,
                 @(type)*, int*, @(type)*, int*);
@precision !

#endif


#ifdef __cplusplus
  }
#endif

#endif /* __SUPERLU_dDEFS */

